# 字节码指令简介
&emsp;&emsp;Java虚拟机的指令由一个字节长度的、代表着某种特定操作含义的数字（称为操作码，Opcode）以及跟随其后的零至多个代表此操作所需参数而构成。

&emsp;&emsp;字节码指令集缺点：
- 限制了Java虚拟机操作码的长度为一个字节，这意味着指令集的操作码总数不可能超过256条，
- 由于Class文件格式放弃了编译后代码的操作数长度对齐，虚拟机在处理数据时，需要重建出具体数据的结构，会导致损失一些性能。

&emsp;&emsp;字节码指令集优点：
- 放弃了操作数对齐，可以省略很多填充和间隔符号，
- 用一个字节来代表操作码，是为了获得短小精干的编译代码。

## 字节码与数据类型
&emsp;&emsp;大部分与数据类型相关的字节码指令，它们的操作码助记符中都有特殊的字符来表明专门为哪种数据类型服务。i代表对int类型的数据操作，l代表对long,s代表short,b代表boolean,c代表char,d代表double,f代表float,a代表reference。

&emsp;&emsp;指令集被设计成非完全独立的，大部分指令都没有支持整数类型byte、char和short,甚至没有任何指令支持boolean类型。

&emsp;&emsp;在处理boolean、byte、short和char类型的数组时，会转换为使用对应的int类型的字节码指令来处理。

## 加载和存储指令
&emsp;&emsp;加载和存储指令用于将数据在栈帧中的局部变量表和操作数栈之间来回传输。
- 将一个局部变量加载到操作栈：iload、lload等
- 将一个数值从操作数栈存储到局部变量表：istore、lstore等
- 将一个常量加载到操作数栈：bipush、sipush、ldc等
- 扩充局部变量表的访问索引的指令：wide

&emsp;&emsp;以尖括号结尾的，如iload_<n>,这些指令的助记符实际上是代表了一组指令，例如iload_<n>,代表了iload_0、iload_1、iload_2。
  
## 运算指令
&emsp;&emsp;运算或算术指令用于对两个操作数栈上的值进行某种特定运算，并把结果重新存入到操作栈顶。

&emsp;&emsp;算术指令可以分为两种：对整型数据进行运算的指令 和 对浮点型数据进行运算的指令

## 类型转换指令
&emsp;&emsp;Java虚拟机直接支持以下数值类型的宽化类型转换（小范围类型向大范围类型的安全转换）：
- int类型到long、float或者double类型
- long类型到float、double类型
- float类型到double类型

&emsp;&emsp;虽然数据类型窄化转换可能会发生上限溢出，下限溢出和精度丢失等情况，但是Java虚拟机规范中明确规定数值类型的窄化转换指令永远不可能导致虚拟机抛出运行时异常。

## 对象创建与访问指令

## 操作数栈管理指令
&emsp;&emsp;Java虚拟机提供了一些用于直接操作操作数栈的指令：
- 将操作数栈的栈顶一个或者两个元素出栈：pop、pop2
- 复制栈顶一个或两个数值并将复制值或双份的复制值重新压入栈顶：dup、dup2、dup_x1等
- 将栈最顶端的两个数值互换：swap

## 控制转移指令
&emsp;&emsp;控制转移指令可以让虚拟机有条件或无条件地从指定的位置继续执行程序。

## 方法调用和返回指令
- invokevirtual指令用于调用对象的实例方法，根据对象的实际类型进行分派，这也是Java语言中最常见的方法分派方式。
- invokeinterface指令用于接口方法，它会在运行时搜索一个实现了这个接口方法的对象，找出适合的方法进行调用
- invokespecial指令用于调用一些需要特殊处理的实例方法，包括实例初始化方法，私有方法和父类方法。
- invokestatic指令用于调用类方法（static方法）
- invokedynamic指令用于在运行时动态解析出调用点限定符所引用的方法，并执行该方法，该指令的分派逻辑是由用户所设定的引导方法决定的。

## 异常处理指令
&emsp;&emsp;在Java虚拟机中，处理异常不是由字节码指令来实现的，而是采用异常表来完成的。

## 同步指令
&emsp;&emsp;Java虚拟机可以支持方法级的同步和方法内部一段指令序列的同步，这两种同步结构都是使用管程来支持的。

&emsp;&emsp;编译器必须确保无论方法通过何种方式完成，方法中调用过的每条monitorenter指令都必须执行其对应的monitorexit指令，而无论这个方法时正常结束还是异常结束。
