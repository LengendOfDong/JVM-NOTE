# 线程安全
## Java语言中的线程安全
&emsp;&emsp;Java语言中各种操作共享的数据分为5类：不可变、绝对线程安全、相对线程安全、线程兼容和线程对立。

## 线程安全的实现方法
&emsp;&emsp;互斥同步是常见的一种并发正确性保障手段。在Java中，最基本的互斥同步手段就是synchronized关键字。

&emsp;&emsp;ReentrantLock增加了一些高级功能：等待可中断，可实现公平锁，以及锁可以绑定多个条件。

&emsp;&emsp;等待可中断是指当持有锁的线程长期不释放锁的时候，正在等待的线程可以选择放弃等待，改为处理其他事情，可中断特性对处理执行时间非常长的同步块很
有帮助。

&emsp;&emsp;公平锁是指多个线程在等待同一个锁时，必须按照申请锁的时间顺序来依次获得锁；而非公平锁则不保证这一点，在锁被释放时，任何一个等待锁的线程都有
机会获得锁。synchronized中的锁是非公平的，ReentrantLock默认情况下也是非公平的，但可以通过带布尔值的构造函数要求使用公平锁。

&emsp;&emsp;锁绑定多个条件是指一个ReentrantLock对象可以同时绑定多个Condition对象。而在synchronized中，锁对象的wait()和notify()或notifyAll()
方法可以实现一个隐含的条件，如果要和多于一个的条件关联的时候，就不得不额外地添加一个锁，而ReentrantLock则无须这样做，只需要多次调用newCondition()方
法即可。

&emsp;&emsp;互斥同步最主要的问题就是进行线程阻塞和唤醒所带来的性能问题，因此这种同步也称为阻塞同步。

&emsp;&emsp;基于冲突检测的乐观并发策略，通俗地说，就是先进性操作，如果没有其他线程争用共享数据，那操作就成功了；如果共享数据有争用，产生了冲突，就再采
取其他的补偿措施（最常见的额补偿措施就是不断地重试，直到成功为止），这种乐观的并发策略的许多实现都不需要把线程挂起，因此这种同步操作也称为非阻塞同步。

&emsp;&emsp;硬件保证一个从语义上看起来需要多次操作的行为只通过一条处理器指令就能完成，这类指令常用的有：
- 测试并设置
- 获取并增加
- 交换
- 比较并交换
- 加载链接、条件存储

&emsp;&emsp;无同步方案有可重入代码和线程本地存储。
- 可重入代码也叫做纯代码，可以在代码执行的任何时刻中断它，转而去执行另外一段代码（包括递归调用本身），而在控制权返回之后，原来的程序不会出现任何错误。相
对线程安全来说，可重入性是更基本的特性，它可以保证线程安全，即所有的可重入代码都是线程安全的，但是并非所有线程安全的代码都是可重入代码。

&emsp;&emsp;可重入代码有一些共同的特征，例如不依赖存储在堆上的数据和公用的系统资源，用到的状态量都是通过参数传入、不调用非可重入的方法等。

&emsp;&emsp;可以通过简单的方法来判断代码是否具备可重入性：如果一个方法，它的返回结果时可以预测的，只要输入了相同的数据，就都能返回相同的结果，那它就满足
可重入性的要求，当然也就是线程安全的。

- 线程本地存储：Java语言中，如果一个变量要被多线程访问，可以使用volatile关键字声明它是”易变的“；如果一个变量要被某个线程独享，Java中可以通过
java.lang.ThreadLocal类来实现线程本地存储的功能。

