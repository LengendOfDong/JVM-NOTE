# 锁优化
## 自旋锁与自适应自旋
&emsp;&emsp;为了让线程等待，只需让线程执行一个忙循环（自旋），这项技术就是所谓的自旋锁。

&emsp;&emsp;自旋等待的时间必须要有一定的限度，如果自旋超过了限定的次数仍然没有成功获得锁，就应当使用传统的方式去挂起线程了。自旋的次数默认是10，用户可以
使用参数-XX：PreBlockSpin来修改。

&emsp;&emsp;在Jdk1.6中引入了自适应的自旋锁。自适应意味着自旋的时间不再固定了，而是由前一次在同一锁上的自旋时间以及锁的拥有者的状态来决定。

&emsp;&emsp;同一个锁对象上，自旋等待刚刚成功获得过锁，并且持有锁的线程正在进行中，那么自旋很有可能成功。另外，如果对于某个锁，自旋很少成功获得过，那在
以后要获取这个锁时将可能省略掉自旋过程。

## 锁消除
&emsp;&emsp;锁消除是指虚拟机即时编译器在运行时，对一些代码上上要求同步，但是检测到不可能存在共享数据竞争的锁进行消除。

&emsp;&emsp;锁消除的主要判定依据来源于逃逸分析的数据支持，如果判断一段代码中，堆上的所有数据都不会逃逸出去从而被其他线程访问到，那就可以把它们当做栈上数
据对待，认为它们时线程私有的，同步加锁自然就无须进行。

## 锁粗化
&emsp;&emsp;如果一系列的连续操作都对同一个对象反复加锁和解锁，甚至加锁操作时出现在循环体中的，那即使没有线程竞争，频繁地进行互斥同步操作也会导致不必要
的性能损耗。

&emsp;&emsp;如果虚拟机探测到一串零碎的操作都对同一个对象加锁，将会把加锁同步的范围扩展（粗化）到整个操作序列的外部。

## 轻量级锁
&emsp;&emsp;轻量级锁并不是用来代替重量级锁的，它的本意是在没有多线程竞争的前提下，减少传统的重量级锁使用操作系统互斥量产生的性能消耗。

&emsp;&emsp;轻量级锁能提升程序同步性能的依据是”对于绝大部分的锁，在整个同步周期内都是不存在竞争的。“在有竞争的情况下，轻量级锁会比传统的重量级锁更慢。

## 偏向锁
&emsp;&emsp;偏向锁也是JDK1.6引入的一项优化，目的是消除数据在无竞争情况下的同步原语，进一步提高程序的运行性能。

&emsp;&emsp;如果说轻量级锁是在无竞争情况下使用CAS操作去消除同步使用的互斥量，那么偏向锁就是在无竞争情况下把整个同步都消除掉，连CAS都不做了。

&emsp;&emsp;偏向锁会偏向于第一个获得它的线程，如果在接下来的执行过程中，该锁没有被其他的线程获取，则持有偏向锁的线程将永远不需要再进行同步。

&emsp;&emsp;偏向锁可以提高带有同步但无竞争的程序性能。如果程序中大多数的锁总是被多个不同的线程访问，那偏向模式就是多余的。
