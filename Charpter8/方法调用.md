# 方法调用
## 解析
&emsp;&emsp;静态解析的成立的前提是：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的。

&emsp;&emsp;在Java语言中符合”编译期可知，运行期不可变“这个要求的方法，主要包括静态方法和私有方法两大类，前者与类型直接关联，后者在外部不可被访问。

&emsp;&emsp;在Java虚拟机里面提供了5条方法调用字节码指令：
- invokestatic:调用静态方法
- invokespecial:调用实例构造器<init>方法、私有方法和父类方法
- invokevirtual:调用所有的虚方法
- invokeinterface:调用接口方法，会在运行时在确定一个实现此接口的对象
- invokedynamic:先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法。

&emsp;&emsp;只要能够被invokestatic和invokespecial指令调用的方法，都可以在解析阶段中确定唯一的调用版本，符合这个条件的有静态方法、私有方法、实例构
造器和父类方法。它们在类加载的时候，就会把符号引用解析为该方法的直接引用。

&emsp;&emsp;final方法虽然是invokevirtual指令来调用，但是它还是非虚方法。

## 分派
&emsp;&emsp;分派调用可能是静态的也可能是动态的，根据分派依据的宗量数可分为单分派和多分派。这两类分派方式的两两组合就构成了静态单分派，静态多分派，动态
单分派和动态多分派。

&emsp;&emsp;静态分派的典型应用是方法重载。静态分派发生在编译阶段，因此确定静态分派的动作实际上不是由虚拟机来执行的。

&emsp;&emsp;重载顺序：char -> int（一次自动转型） -> long（两次自动转型） -> float -> double -> Character(装箱) -> Serializable（装箱类父类）-> Object（顶级父类）-> char...(变长类型)

&emsp;&emsp;动态分派中关键的是invokevirtual指令。invokevirtual指令的运行时解析过程大致分为以下几个步骤：
- 找到操作栈顶的第一个元素所指向的对象的实际类型，记作C
- 如果在类型C中找到与常量中的描述符合简单名称都相符的方法，则进行访问权限校验，如果通过则返回这个方法的直接引用，查找过程结束；如果不通过，则返回java.lang.IllegalAccessError异常
- 否则，按照继承关系从下往上依次对C的各个父类进行第2步的搜索和验证过程
- 如果始终没有找到合适的方法，则抛出java.lang.AbstractMethodError异常

&emsp;&emsp;Java语言重写的本质：由于invokevirtual指令执行的第一步就是在运行期确定接收者的实际类型，所以invokevirtual指令把常量池中的类方法符号引用解析到了不同的直接引用上。

&emsp;&emsp;运行期根据实际类型确定方法执行版本的分派过程叫做动态分派。

## 单分派和多分派


