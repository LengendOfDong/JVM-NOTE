# 类加载器
&emsp;&emsp;虚拟机设计团队把类加载阶段中的”通过一个类的全限定名来获取描述此类的二进制字节流“这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定
如何去获取所需要的类。实现这个动作的代码模块称为”类加载器“。

## 类与类加载器
&emsp;&emsp;对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性。如果加载同一个类的加载器不同，那么两个类就必定不相
等。

## 双亲委派模型
&emsp;&emsp;从Java虚拟机的角度来讲，只存在两种不同的类加载器：一种是启动类加载器，这个类加载器使用c++语言实现，是虚拟机自身的一部分;另一种就是所有其
他的类加载器，这些类加载都由Java语言实现，独立于虚拟机外部，并且全都继承自抽象类java.lang.ClassLoader。

&emsp;&emsp;从Java开发人员的角度来看，绝大多数都会使用到以下3种系统提供的类加载器：
- 启动类加载器（BootStrap ClassLoader）:这个类加载器负责将存放在<JAVA_HOME>\lib目录中的，或者被-Xbootclasspath参数所指定的路径中的，并且是虚拟机识别的类库加载到虚拟机内存中。
- 扩展类加载器（Extension ClassLoader):这个类加载器由sun.misc.Launcher$ExtClassLoader实现，它负责加载<JAVA_HOME>\lib\ext目录中的，或者被java.ext.dirs系统变量所指定的路径中的所有类库，开发者可以直接使用扩展类加载器。
- 应用程序类加载器（Application ClassLoader):这个类加载器由sun.misc.Launcher$AppClassLoader实现。它负责加载用户类路径（ClassPath）上所指定的类库，开发者可以直接使用这个类加载器。

&emsp;&esmp;双亲委派模型要求除了顶层的启动类加载器外，其余的类加载器都应该有自己的父类加载器。类加载器之间的父子关系一般不会以继承的方式来实现，而是以组合的关系来复用父加载器。

&emsp;&esmp;双亲委派模型的工作过程是：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。

&emsp;&emsp;使用双亲委派模型的好处就是Java类随着它的类加载器一起具备了一种带有优先级的层级关系。Object类可以保证每次都是启动类加载器在进行加载，保证Object类在程序的各种类加载器环境中都是同一个类。

&emsp;&emsp;双亲委派模型对于保证Java程序的稳定运作很重要，实现逻辑：先检查是否已经被加载过，如果没有加载则查找父类加载器，如果父类加载器为空，则使用启动类加载器进行加载（启动类加载器没有父类加载器），如果父类加载器不为空，则使用父类加载器进行加载，父类加载器加载失败，则抛出异常后调用自己的加载器进行加载。

## 破坏双亲委派模型
&emsp;&emsp;OSGI将按照下面的顺序进行类搜索：
- 将以java.*开头的类委派给父类加载器加载
- 否则，将委派列表名单内的类委派给父类加载器加载
- 否则，将Import 列表中的类委派给Export这个类的Bundle的类加载器加载
- 否则，查找当前Bundle的ClassPath,使用自己的类加载器加载
- 否则，查找类是否在自己的Fragment Bundle中，如果在，则委派给Fragment Bundle的类加载器加载
- 否则，查找Dynamic Import列表的Bundle，委派给对应Bundle的类加载器加载。
- 否则，类查找失败


