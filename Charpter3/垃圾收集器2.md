#垃圾收集器
## Serial Old收集器
&emsp;&emsp;Serial Old收集器是Serial收集器的老年代版本，它同样是一个单线程收集器，使用”标记-整理“算法。

&emsp;&emsp;这个收集器的主要意义在于给Client模式下的虚拟机使用。

&emsp;&emsp;Serial Old收集器如果在Server模式下，那么它主要还有两大用途：
- 在JDK 1.5以及之前的版本中与Parallel Scavenge收集器搭配使用
- 作为CMS收集器的后备预案，在并发收集发生Concurrent Mode Failure时使用

## Parallel Old收集器
&emsp;&emsp;Parallel Old是Parallel Scavenge收集器的老年代版本，使用多线程和”标记-整理“算法。这个收集器是在JDK 1.6中才开始提供的。

&emsp;&emsp;如果新生代选择Parallel Scavenge收集器，老年代若选择Serial Old收集器，就会造成性能瓶颈，因为Serial Old收集器在服务端应用性能上的
瓶颈，无法充分利用服务器多CPU的处理能力。

&emsp;&emsp;在注重吞吐量以及CPU资源敏感的场合，都可以优先考虑Parallel Scavenge加Parallel Old收集器。

## CMS收集器
&emsp;&emsp;CMS(Concurrent Mark Sweep)收集器是一种以获取最短回收停顿时间为目标的收集器。

&emsp;&emsp;CMS收集器的适用场合：目前互联网站或者B/S系统的服务器上，系统停顿时间越短，给用户的体验越好，CMS收集器越合适。

&emsp;&emsp;CMS收集器是基于”标记-清除“算法实现的，它的运作过程分为4个步骤：
- 初始标记（CMS initial mark)
- 并发标记（CMS concurrent mark)
- 重新标记（CMS remark)
- 并发清除（CMS concurrent sweep)

&emsp;&emsp;初始标记仅仅只是标记一下GC Roots能直接关联到的对象，速度很快。

&esmp;&emsp;并发标记阶段就是进行GC Roots Tracing的过程。

&emsp;&emsp;重新标记阶段则是为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记，这个阶段的停顿时间一般会比初始标记阶段稍长
一些，但远比并发标记的时间短。

&emsp;&emsp;CMS的主要优点：并发收集，低停顿，Sun公司也称之为并发低停顿收集器。

&emsp;&emsp;CMS的主要缺点：
- CMS收集器对CPU资源非常敏感
- CMS收集器无法处理浮动垃圾，在JDK 1.6中，CMS收集器的启动阈值已经提升至92%。要是CMS运行期间预留的内存无法满足程序需要，就会出现一次”Concurrent 
Mode Failure"失败，这是虚拟机将启动后备预案：临时启用Serial Old收集器来重新进行老年代的垃圾收集，这样停顿时间就太长了。
- CMS是一款基于“标记-清除”算法实现的收集器，收集结束时会有大量空间碎片产生。-XX:+UseCMSCompactAtFullCollection开关参数（默认是开启的），用于
CMS内存碎片的合并整理，-XX:CMSFullGCsBeforeCompaction，这个参数用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的。

## G1收集器


