# HotSpot的算法实现
## 枚举根节点
&emsp;&emsp;目前的主流Java虚拟机使用的都是准确式GC，所以当执行系统停顿下来后，并不需要一个不漏地检查完所有执行上下文和全局的引用位置，虚拟机应当是
有办法直接得知哪些地方存放着对象引用。在HotSpot的实现中，使用一组称为OopMap的数据结构来达到这个目的的，在类加载完成后，HotSpot就把对象内什么偏移量
上是什么类型的数据计算出来，在JIT编译过程中，也会在特定的位置记录下栈和寄存器中哪些位置是引用。这样GC在扫描时就可以直接得知这些信息了。

## 安全点
&emsp;&emsp;在OopMap的协助下，HotSpot可以快速且准确地完成GC Roots枚举。

&emsp;&emsp;HotSpot没有为每条指令都生成OopMap,只是在“特定的位置”记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始GC，
只有在到达安全点时才能暂停。

&emsp;&emsp;安全点的选定既不能太少以致于让GC等待时间太长，也不能太过于频繁以致于过分增大运行时的负荷。所以，安全点的选定基本上是以程序“是否具有让程序长时间执行的特征”为标准进行选定的。“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生安全点。

&emsp;&emsp;对于安全点，另一个需要考虑的问题就是如何在GC发生时让所有线程都在最近的安全点上再停顿下来。这里有两种方案：抢先式中断和主动式中断。
- 抢先式中断：不需要线程的执行代码主动去配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点上。

- 主动式中断：当GC需要中断线程的时候，不直接对线程操作，仅仅简单地设置一个标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起。轮询标志的地方和安全点是重合的，另外再加上创建对象需要分配内存的地方。

## 安全区域
&emsp;&emsp;线程无法响应JVM的中断请求，“走”到安全的地方去中断挂起，JVM也显然不太可能等待线程重新被分配CPU时间。对于这种情况，就需要安全区域来解决。

&emsp;&emsp;安全区域是指在一段代码片段之中，引用关系不会发生变化。在这个区域中的任意地方开始GC都是安全的。安全区域可以看做是被扩展了的安全点。

&emsp;&emsp;在线程进入安全区域时，会标识自己已经进入了安全区域，在线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举，如果完成了，那线程就继续执行，否则它就必须等待直到收到可以安全离开安全区域的信号为止。

