# 对象已死吗
&emsp;&emsp;GC的历史比Java久远，Lisp是第一门真正使用内存动态分配和垃圾收集技术的语言。主要考虑回收的三方面问题：
- 哪些内存需要回收？（What）
- 什么时候回收？(When)
- 如何回收？(How)

&emsp;&emsp;当需要排查各种内存溢出、内存泄露问题时，当垃圾收集成为系统达到更高并发量的瓶颈时，我们就需要对这些”自动化“的技术实施必要的监控和调节。

&emsp;&emsp;程序计数器、虚拟机栈、本地方法栈3个区域随线程而生，随线程而灭；栈中的栈帧随着方法的进入和退出而有条不紊地执行者出栈和入栈的操作。每一个栈帧中分配多少内存基本上是在类结构确定下来时就已知的。因此在这几个区域的内存分配和回收都具备确定性，在这几个区域内就不需要过多考虑回收的问题，因为方法结束或者线程结束时，内存自然就跟着回收了。

&emsp;&emsp;Java堆和方法区则不一样，一个接口中的多个实现类需要的内存可能不一样，一个方法中的多个分支需要的内存也可能不一样，我们只有在程序处于运行期间时才能知道会创建哪些对象，这部分内存的分配和回收是动态的，垃圾收集器所关注的是这部分内存。

## 引用计数法
&emsp;&emsp;给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值就加1；当引用失效时，计数器值就减1；任何时刻计数器为0的对象就是不可能再被使用的。

&emsp;&emsp;主流的Java虚拟机里面没有选用引用计数器算法来管理内存的，其中最主要的原因是它很难解决对象之间相互循环引用的问题。
