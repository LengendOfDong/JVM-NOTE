# HotSpot虚拟机对象探秘

## 对象的创建
虚拟机遇到一条new指令时：

1）首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并且检查这个符号引用代表的类是否已被加载
、解析和初始化过。如果没有那必须先执行相应的类加载过程。

2）在类加载检查通过后，接下来虚拟机将会为新生对象分配内存。对象所需内存的大小在类加载完成后便可完全确定。
- 指针碰撞（Bump the pointer):假如Java堆中的内存时绝对规整的，所有用过的内存放在一边，空闲的内存放在另一边，中间放着一个指针作为分界点的指示器，那所有分配内存就是仅仅是把那个指针向空闲空间那边挪动一段与对象大小相等的距离。
- 空闲列表 (Free List):假如Java堆中的内存并不是规整的，已使用的内存与空闲的内存相互交错，那就没有办法简单地进行指针碰撞了，虚拟机就必须维护一个列表，记录哪些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

&emsp;&emsp;选择哪种分配方式由Java堆是否规整决定，而Java堆是否规整又由所采用的的垃圾收集器是否带有压缩整理功能决定。（这就像Windows删除文件后，使用磁盘整理一样）

3) 修改指针所指向的位置，在并发情况下也并不是线程安全的，可能出现冲突的情况，解决这个问题有两种方案：
- 对分配内存空间的动作进行同步处理，通过采用CAS配上失败重试的方式保证更新操作的原子性
- 把内存分配的动作按照线程划分在不同的空间之中进行，即每个线程都会有自己的独立内存，当需要分配内存时，就先从独立内存中获取，只有独立内存用完时，才需要同步锁定。虚拟机是否使用本地线程分配缓冲（TLAB），可以通过-XX：+/- UserTLAB参数来决定。

4) 内存分配完成后，虚拟机需要将分配到的内存空间都初始化为零值（不包括对象头），如果使用TLAB，这一工作过程也可以提前至TLAB分配时进行。这一步操作保证了对象的实例字段在Java代码中可以不赋初值就可直接使用，程序能访问到这些字段的数据类型所对应的零值。

5) 虚拟机对对象进行必要的设置，例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的GC分代年龄等信息。这些信息存放在对象的对象头之中。根据虚拟机当前的运行状态不同，如是否启用偏向锁等，对象头会有不同的设置方式。

6) 完成上述步骤之后，从虚拟机的视角来看，一个新的对象已经产生了，但从Java程序的视角来看，对象创建才刚刚开始。一般来说，执行new指令之后会接着执行\<init\>方法，把对象按照程序员的意愿进行初始化，这样一个真正可用的对象才算真正产生出来。
  
## 对象的内存布局
&emsp;&emsp;在HotSpot虚拟机中，对象在内存中存储的布局可以分为3块区域：对象头（Header)、实例数据（Instance Data)和对齐填充（Padding)。
&emsp;&emsp;HotSpot虚拟机的对象头包括两部分信息，第一部分用于存储对象自身的运行时数据，如哈希码（HashCode）、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID、偏向时间戳等。这部分数据的长度在32位和64位的虚拟机中分别为32bit和64bit，官方称为”Mark Word"。
&emsp;&emsp;对象头信息是与对象自身定义的数据无关的额外存储成本，考虑到虚拟机的空间效率，Mark Word被设计成一个非固定的数据结构以便在极小的空间内存储尽量多的信息，它会根据对象的状态复用自己的存储空间。例如，在32位的HotSpot虚拟机中，如果对象处于未被锁定的状态下，那么Mark Word的32bit空间中的25bit用于存储对象哈希码，4bit用于存储对象分代年龄，2bit用于存储标志位，1bit固定为0，而在其他状态（轻量级锁定，重量级锁定，GC标记，可偏向）下的存储内容如下：

|存储内容|标志位|状态|
|-|-|-|
|对象哈希码、对象分代年龄|01|未锁定|
|指向锁记录的指针|00|轻量级锁定|
|指向重量级锁的指针|10|膨胀（重量级锁定）|
|空，不需要记录信息|11|GC标记|
|偏向线程ID、偏向时间戳、对象分代年龄|01|可偏向|

&emsp;&emsp;对象头的另外一部分是类型指针，即对象指向它的类元数据的指针，虚拟机通过这个指针来确定这个对象是哪个类的实例。如果对象是一个Java数组，那在对象头中还必须有一块用于记录数组长度的数据，因为虚拟机可以通过普通Java对象的元数据信息确定Java对象的大小，但是从数组的元数据中却无法确定数组的大小。

&emsp;&emsp;实例数据部分是对象真正存储的有效信息，也是在程序代码中所定义的各种类型的字段内容。无论是从父类继承下来的，还是在子类中定义的，都需要记录起来。这部分的存储顺序会受到虚拟机分配策略参数和字段在Java源码中定义顺序的影响。HotSpot虚拟机默认的分配策略为longs/doubles、ints、shorts/chars、bytes/booleans、oops。

&emsp;&emsp;第三部分对齐填充并不是必然存在的，也没有特别的含义，它仅仅起着占位符的作用。由于HotSpot VM的自动内存管理系统要求对象起始地址必须是8字节的整数倍，所以对象的大小必须是8字节的整数倍。而对象头部分正是8字节的倍数，因此，当对象实例数据部分没有对齐时，就需要通过对齐填充来补齐。

## 对象的访问定位
&emsp;&emsp;Java对象需要通过栈上的reference数据来操作堆上的具体对象，reference类型在Java虚拟机规范中只规定了一个指向对象的引用。对象访问方式也是取决于虚拟机实现而定的，目前主流的访问方式有使用句柄和直接指针两种。
- 如果使用句柄访问的话，那么Java堆中将会划分出一块内存来作为句柄池，reference中存储的就是对象的句柄地址，而句柄中包含了对象实例数据和类型数据各自的具体地址信息。
- 如果使用直接指针访问，那么Java堆对象的布局中就必须考虑如何放置访问类别数据的相关信息，而reference中存储的直接就是对象地址。

&emsp;&emsp;这两种对象访问方式各有优势，使用句柄来访问的最大好处就是reference中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而reference本身不需要修改。

&emsp;&emsp;使用直接指针访问方式的最大好处就是速度更快，它节省了一次指针定位的时间开销，由于对象的访问在Java中非常频繁，因此此类开销积少成多后也是一项非常可观的执行成本。虚拟机Sun HotSpot是使用第二种方式进行对象访问的。

&emsp;&emsp;当要频繁移动对象时，句柄方式是很有优势的；当频繁访问对象时，只需一次指针定位的直接指针方式一定比两次指针定位的句柄方式更有优势。通常来说，访问应该比移动要更加频繁，所以直接指针方式应该更好些。
